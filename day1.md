2：Home模块组件拆分
--先把静态页面完成
--拆分出静态组件
--获取服务器的数据进行展示
--动态业务


3：三级联动组件完成
--由于三级联动，在Home，Search，Detail，把三级联动注册为全局组件。
好处：只需要注册一次，就可以在项目任意地方使用

7.接口统一管理
项目很小:完全可以在组件内的生命周期函数中发请求
项目很大：axios.ge('xxx')

7.1跨域问题
--什么是跨域问题：协议，域名端口号不同的叫跨域问题
http://localhost:8080/#/home  --前端项目的本地服务器
http://39.98.123.211          --后台服务器

JSONP ,CROS ,代理跨域





 8.nprogress进度条的使用

 staet:进度条开始
 done：进度条结束
 进度条颜色是可以修改的，需要修改样式nprogress/nprogress.css




 9.vuex状态管理库

 9.1 vuex是什么？
---官方提供的一个插件，状态管理库，集中式管理项目中组件共用的数据

只有项目大，组件，数据多，维护困难才用vuex
state,mutations,actions,getters,modules


10.函数的防抖与节流

节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发
防抖：前面的所有触发都被取消，最后一次的执行在规定的时间之后才被触发，也就是说如果连续快速的触发，只会执行一次


11.三级联动路由的跳转与传递参数
  
  三级联动用户可以点击的：一级分类，二级分类，三级分类，当你点击的时候
  Home模块跳转到Search模块，一级会把用户选中的产品（产品的名字，产品的ID）在路由跳转的时候，进行传递。

路由跳转：
声明式导航：router-link
编程式导航：push | replace

复习：
1）商品分类的三级列表由静态变为动态形式【获取服务器数据，解决跨域问题】
2）防抖与节流
3）路由的跳转：声明式导航（组件：router-link）|编程式导航


1）开发Search模块中的TypeNav商品分类菜单（过渡动画效果）
过渡动画：前提组件|元素务必要有v-if|v-show指令才可以进行过渡动画


2）现在咱们的商品分类三级列表可以进行优化？
在APP根组件当中发请求【根组件mounted】执行一次

3）合并params与query参数？


4）开发Home首页当中的ListContainer组件与Floor组件
印记中文
但是这里需要知道的一件事情：服务器返回的数据（接口）只有商品分类菜单数据，对于Listcontainer组件月Floor组件的数据服务器是没有提供的。

mock数据(模拟)：想要mock一些数据，需要用到一个插件mockjs

使用步骤：
1）在项目中src文件夹中创建mock文件夹
2）第二步准备JSON数据（mock文件夹中创建相应的JSON文件）----格式化一下，不能留有空格
3）把mock数据需要的图片放置到public文件夹中【public文件夹在打包的时候，会把相应的资源原封不动的打包到dist文件夹中】
4）创建mockserve.js通过插件mockjs实现模拟数据
5）mockServe.js文件早入口文件中引入（至少需要执行一次才能模拟数据）



5）List Container组件开发的重点？
安装Swiper插件：最新版本7，安装的是swiper@5
npm i swiper@5

复习：
1）完成商品分类的三级列表路由跳转，一级路由传参（合并参数）
2）完成serch模块中对于typeNavav使用（过渡动画的优化）
3）对于typeNavav请求次数也进行了优化
4）swiper插件
swipe让插件：自己由于制作轮播图（移动端|PC端）
使用步骤：
第一步：引入相应依赖包（swiper.js|swiper.css）
第二步：页面中的结构必须有
第三步：初始化swiper实例，给轮播图添加动态效果
5）mock数据：通过mockjs模块实现


5）最完美的解决方案：解决轮播图问题
watch+nextTick:数据监听，监听已有的数据变化
 $nextTick:nexTick：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这方法，获取更新后的DOM
  $nextTick:可以保证页面中的结构是一定在的，经常和很多插件一起使用【需要DOM已经存在了】
   API --发请求--vuex三连环--捞数据--展示数据

2）开发Floor组件
切记：仓库中的state的数据格式，取决于服务器返回的数据
2.1geFloorList这个action在哪里触发，是需要在Home路由组件当中发的,不能在Floor内部组件发action ，因为需要v-for遍历组件

2.2v-for也可以在自定义标签当中使用


2.3组件通信的方式有哪些
props:父子组件通信
自定义事件：$on  $emit 可以实现子给父通信
自定义事件总线：$bus 全能
pubsub-js；vue当中几乎不用 全能
插槽
vuex


3）把首页当中的轮播图拆分为一个公用的全局组件
切记：以后在开发项目的时候，如果看到某一个组件在很多地方使用，应该把它设置为全局组件
注册一次，就可以在任意地方使用，公用的组件 | 非路由组件放到components文件夹中



4）Search模块开发
 1：先静态页面+静态组件拆分出来
 2：发请求（API）
 3：vuex三连环
 4：组件获取仓库数据，动态展示数据


 
复习：
1）search模块需要的服务器数据，已经存储于vuex的仓库中，而且有一些数据【已经通过getter进行简化】 切记：getter简化数据
2商品列表，平台售卖属性以及动态数据（来自于服务器的数据）



1）动态开发面包屑中的分类名
编程式导航路由跳转【自己跳自己】

2）动态开发面包屑中的关键字
2.1当面包屑中的关键字被清除以后，需要让兄弟组件Header组件中的关键字清除
组件通信方法：
props:父子
自定义事件：子父
vuex：万能
插槽：父子
pubsub-js：万能
$bus：全局事件总线（万能）





重点：排序操作
1：综合，2：价格 asc:升序，desc:降序
示例：‘1：desc’

1.1问题
order属性的属性值最多有多少种写法：
1：asc
1:desc
2:asc
2:desc

1.2考虑的问题
谁应该有类名：通过order属性值当中是1（综合）还是2（价格）

1.3谁应该有箭头
谁有类名谁有箭头

1.4箭头用什么制作？
阿里图标库


分页的开发
1）为什么很多项目采用分页功能：比如电商平台展示的数据有很多（1W+）
采用分页功能（Element是有相应的分页组件使用起来简单，但是前台项目暂时不用）【必须掌握自定义分页功能】

2）分页器展示需要哪些数据（条件）
 1.需要知道当前是第几个：pageNo字段代表当前页数

 2.需要知道每一页需要展示但是条数据：pageSize字段来进行代表

 3.需要知道整个服务器有多少条数据:total字段进行代表【获取另外一条信息多：多少页】
  4.需要知道分页器连续页面的个数：5|7【因为对称】
  总结;对于分页器而言，自定义前提需要知道四个条件.
  pageNo:当前第几个
  pageSize：一页有多少个
  total：整个分页一共要展示多少条数据
  continues:代表分页器连续页码个数


  3）自定义分页器，在开发的时候先自己传递假的数据模拟调试，直到调试成功再用服务器的数据

  4）对于分页器而言：需要算出起始数字和结束数字
  当前是第八页
  |1|2|...|6|7|8|9|10|...|31| 

注意：假如当前是第一页
-1 0 1 2 3

5）分页器动态展示？【中间的部分】
v-for:数组|数字|字符串|对象
手写分页器

7）开发某一个产品的详情页面
1：搞定静态页面（需要注册为路由组件）
当点击商品的时候，跳转到详情页面，再路由跳转的时候需要带上产品的ID给详情页面
2：发请求 API 请求接口
3：vuex三连环
4：动态展示组件

8）数据解释？---售卖属性


9）
1.1加入购物车按钮
1.2路由跳转之前发请求
1.3路由跳转成功与传递参数
本地存储：持久化的---5M
会话存储：非持久化的--会话结束存储消失
1.4路由跳转失败提示失败信息

2.1addCartSuccess
2.2查看详情
2.3查看购物车

3.1购物车
3.2购物车静态组件-需要修改样式结构
调整css让各个项目对齐，删除第三项  15   35   10  17   10  13
3.3向服务器发起ajax请求，获取购物车数据
发现：发请求的时候获取不到购物车里面的数据，因为服务器不知道你是谁
3.4UUID临时游客身份

3.5动态展示购物车
数据格式有点不完美
4.1修改购物车产品的数量(需要发请求，参数理解)
5.1修改产品个数【函数的节流】
6.1删除某一个产品

10
1）删除选中的产品
复习：
1.1加入购物车
UUID：点击加入购物车的时候，通过请求头给服务器带临时身份给服务器，存储某一个用户的购物车数据
会话存储：去存储产品的信息一级展示功能
1.2购物车功能
修改产品数量
删除某一个产品的接口
某一个产品的勾选状态切换


2）删除选中全部产品的操作
注意：没有一次删除很多产品的接口，但是有通过ID可以删除产品的接口【一次删除一个】
Promise.all([p1,p2,p3])
p1|p2|p3:每一个都是promise对象，如果有一个promise失败，返回失败，若都成功，则返回成功

3）登陆与注册静态组件（处理共用图片资源问题）
登陆与注册功能（git）:必须要会的技能
assets文件夹---组件是放所有组件共用的静态资源

4）注册的业务---表单验证先不做
4.1获取验证码----/api/user/passport/sendCode/{phone}
4.2注册的业务
4.1注册业务|登陆业务中表单验证先不处理
4.2获取验证码的接口  /api/user/passport/sendCode/{phone}  get
5）登陆业务
先注册---通过数据库存储用户信息（名字，密码）
登陆---登陆成功的时候，后台为了区分用户是谁-服务器下发token[令牌：唯一的标识符]
登陆：做的不完美，一般登陆成功后服务器会下发token,前台持久化存储token,【带着token找服务器要用户信息进行展示】


6）token令牌

注意：vuex仓库存储数据---不是持久化的

1）登陆过后首页用户信息的展示

1.1当用户完成注册，用户登陆【用户名+密码】向服务器发请求（组件派发action:userLogin）,登陆成功获取到token,存储在仓库当中（非持久化的），路由跳转到首页

1.2因此在首页当中（mounted）派发action(getUserInfo)获取用户信息，一级动态展示header组件内容

1.3一刷新home首页，获取不到用户信息（toke:vuex非持久化存储）

1.4持久化存储token

1.5存在的问题1，多个组件展示用户信息需要在每一个组件的mounted中发
this.$store.dsipatch('getUserInfo') 不行

1.6存在的问题2，用户已经登陆了，就应该到不了登陆页面

2）退出登陆

3）导航守卫
导航：表示路由正在发生改变，进行路由跳转
守卫：：看门护卫

全局守卫：项目中只要发生路由的变化，守卫就能监听到
路由独享守卫
组件内守卫
比如：用户已经登陆，用户不应该还能回到login页面


1）交易页面完成（商品清单）
动态展示数据完成

2）提交订单
2.1先把支付静态组件完成
2.2点击提交订单的按钮的时候，还需要向服务器发起一次请求【把支付的一些信息传递给服务器】

3）获取支付信息（不再使用vuex）
3.1别在生命周期周期函数中使用async
3.2获取支付信息
4）elementUI使用+按需引入
已经学习过的组件库：
react(Vue):antd[pc] antd-mobile[移动端]
Vue:ElementUI   Vant[移动端]
4.1 ElementUI的按需引入，配置文件发生变化，项目需要重启的
5）二维码生成qrcode

6）支付业务

7）个人中心







1）个人中心
面试的时候：是否封装过组件：分页器，日历，轮播图
个人中心当中：分页器















2）全局守卫
为登陆访问，交易相关（trade）,支付相关（pay,paysuccess）,用户中心（center）
相关跳转到登录页面


3）组件独享守卫
只有从购物车界面才能跳转到交易页面（创建订单）
只有从交易页面（创建订单）才能跳转到支付页面
只有从支付页面才能跳转到支付成功页面












4）图片懒加载
https://www.npmjs.com/package/vue-lazyload
5）vee-validate基本使用
第一步：安装插件与引用
npm i vee-validate@2 
import VeeValidate from 'vee-validate'
import zh_CN from 'vee-validate/dist/locale/zh_CN'
Vue.use(VeeValidate)





6）路由懒加载

7）打包上线
7.1打包npm run build
项目打包后，代码都是结果压缩加密的，如果运行时报错，输出的错误信息无法得知是哪里的代码报错
有了map就可以像未加密的代码一样，准确的输出是哪一行哪一列有错
vue.config.js配置
 productionSourceMap: false,

 8）购买服务器
 1：阿里云  2：腾讯云  等等
 2:设置安全组，让服务器的一些端口号打开
 3：利用xshell工具登陆服务器
 linux:  /根目录
 linux常用的指令：cd 跳转目录  ls 查看  mkdir 创建目录  pwd 查看绝对路径


 9）nginx反向代理

 yum install nginx [etc]

 location / {
        root   /root/wse/www/shangpinhui/dist
        index   index.html
        try_files  $uri $uri/ /index.html
 }

 location /api {
   proxy_pass http://121.196.224.74
 }
   service nginx start
   service nginx restart
   service nginx stop



   项目的数据来自于http://39.98.123.211

    nginx配置：
    1：xshell进入根目录/etc
    2:进入etc目录，这个目录下有一个nginx目录【进入到这个目录】
    3：如果想安装nginx : yum install nginx [etc]
    4:安装完了后。在目录下多了个nginx.conf文件，在这个文件下配置
    5：vim nginx.conf进行编辑
    6:nginx服务器跑起来
    service nginx start
   service nginx restart
   service nginx stop


